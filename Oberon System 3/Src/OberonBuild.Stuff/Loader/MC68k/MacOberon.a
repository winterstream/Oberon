*------------------------------------------------------------------------------------* MacOberon S3		3.11.95	; Copyright by Michael Franz/Thomas Kistler - All Rights Reserved*------------------------------------------------------------------------------------	MACHINE	MC68020	PRINT	PUSH, OFF		INCLUDE 'Traps.a'		INCLUDE 'SysEqu.a'		INCLUDE 'QuickEqu.a'		INCLUDE 'GestaltEqu.a'	PRINT	POP_CacheFlush	OPWORD	$A0BDOBGlobals	RECORD	0ResHandle	DS.L	1	; -72 REFERENCEDPtrTbl	DS.L	8	; 16..128PtrGtr	DS.L	1	; > 128Sentinel	DS.L	1	; always set to -1HeapRoot	DS.L	1	; list of heap blocksModRoot	DS.L	1	; -24 EXPORTEDMark1	DS.L	1	; -20 EXPORTEDScan	DS.L	1	; -16 EXPORTEDNewSys	DS.L	1	; -12 EXPORTEDNewLarge	DS.L	1	; -08 EXPORTEDNewSmall	DS.L	1	; -04 EXPORTED	ENDR	EXPORT (QD):DATAQD	DS	QDGlobals	EXPORT (G):DATAG	DS	OBGlobals*------------------------------------------------------------------------------------* PROCEDURE NewSmall	; NEW(ptrToSmallType)**   A1: Address of Pointer to New Block*   A2: Tag, TypeSize <= 128 incl tag, aligned to 16, size in tag is divided by 4*NewSmall	PROC	EXPORT	MOVE.L	(A2), D1	; D1: (size DIV 4)	LEA.L	-72(A5, D1.L), A3	; should be "G.PtrTbl-4(A5, D1.L)"@1	TST.L	(A3)+	; search for smallest fitting block	BEQ.S	@1	BMI.S	Alloc	; sentinelBlkFound	MOVE.L	-(A3), A0	; get block	MOVE.L	(A0), (A3)	; remove from list	MOVE.L	4(A0), D0	; (size DIV 4) of block at -4(A0)	SUB.L	D1, D0	; (size of rest) DIV 4	BEQ.S	Return	MOVEA.L	A0, A3	LEA.L	0(A0, D0.L*4), A0	; A0: new; A3: rest	MOVE.L	D0, 4(A3)	; (size of rest) DIV 4	CMP.W	#36, D0	; 4*32=128	BLS.S	Register	MOVEQ.L	#36, D0Register	LEA.L	-72(A5, D0.L), A4	; should be "G.PtrTbl-4(A5, D0.L)"	MOVE.L	(A4), (A3)	; insert rest in list	MOVE.L	A3, (A4)Return	MOVE.L	A2, -4(A0)	; type tag	MOVE.L	A0, (A1)	; assign new value to pointer	SUBQ.L	#2, D1	; clear (size-tagsize) positions@2	CLR.L	(A0)+	; clear new block	DBF.W	D1, @2	RTSAlloc	MOVE.L	#$10000, D0	; 64k	_NewPtr	TPNE.W	#23	MOVE.L	A0, D2	MOVE.L	G.HeapRoot(A5), (A0)+	; insert in list	MOVE.L	D2, G.HeapRoot(A5)	CLR.L	(A0)+	; put nil tag to identify chunk	ADDQ.L	#4, A0	; space for block tag	MOVE.L	A0, G.PtrGtr(A5)	; link to large blocklist	CLR.L	(A0)+	; is last in list	MOVE.L	A0, -8(A0)	; tag points to size	MOVE.L	#$3FFC, (A0)	; set size to 64k-16	SUBQ.L	#4, A3	; A3 still points to sentinel	BRA.S	BlkFound	ENDP*------------------------------------------------------------------------------------* PROCEDURE NewLarge	; NEW(ptrToLargeType)**   A1: Address of Pointer to New Block*   A2: Tag, TypeSize > 128 incl tag and link, aligned to 4*NewLarge	PROC	EXPORT	MOVE.L	(A2), D0	; size	_NewPtr 	,CLEAR	TPNE.W	#23	MOVE.L	A0, D2	MOVE.L	G.HeapRoot(A5), (A0)+	; insert in list	MOVE.L	D2, G.HeapRoot(A5)	MOVE.L	A2, (A0)+	; put type tag	MOVE.L	A0, (A1)	; assign pointer	RTS	ENDP*------------------------------------------------------------------------------------* PROCEDURE NewSys		; NEW(ptrToArray) or SYSTEM.NEW()**   A1: Address of Pointer to New Block*   D0: Size of Block*NewSys	PROC	EXPORT	ADDQ.L	#8, D0	; link and tag	ADDQ.L	#3, D0	; align	AND.W	#$FFFC, D0	MOVE.L	D0, D1	_NewPtr	,CLEAR	TPNE.W	#23	MOVE.L	A0, D2	MOVE.L	G.HeapRoot(A5), (A0)+	; insert in list	MOVE.L	D2, G.HeapRoot(A5)	NEG.L	D1	; create size tag	MOVE.L	D1, (A0)+	; put size tag	MOVE.L	A0, (A1)	; assign pointer	RTS	ENDP*------------------------------------------------------------------------------------* PROCEDURE Mark1		; Mark Global Pointers of one Module**   A1: Pointer to globals in A1, Marked Global Descriptor at -4(A1)*Mark1	PROC	EXPORT	MOVEA.L	#0, A0	; ptr to father	MOVE.L	-4(A1), A3	; load MARKED type desc ptr	BRA.S	PtrLoopPtrUp	SUBA.L	D0, A3	; correct type desc ptr	MOVE.L	A3, -4(A1)	; save type desc ptr - still marked!	TST.L	A0	BNE.S	@1	; end if father = NIL	RTS@1	MOVEA.L	-4(A0), A3	; load type desc ptr	MOVE.L	-1(A3), D0	; next ptr offset	MOVEA.L	0(A0,D0), A2	; rotate ptrs	MOVE.L	A1, 0(A0,D0)	MOVEA.L	A0, A1	MOVEA.L	A2, A0PtrLoop	SUBQ.L	#4, A3	MOVE.L	-1(A3), D0	; next ptr offset	BMI.S	PtrUp	; negative -> end	MOVE.L	0(A1, D0.L), A2	; new son	TST.L	A2	BEQ.S	PtrLoop	; son = NIL	BSET.B	#0, -1(A2)	BNE.S	PtrLoop	; son marked	BTST.B	#7, -4(A2)	BNE.S	PtrLoop	; son created by SYSTEM.NEWPtrDown	MOVE.L	A3, -4(A1)	; save type desc ptr	MOVE.L	A0, 0(A1, D0)	; rotate ptrs	MOVE.L	A1, A0	MOVE.L	A2, A1	MOVE.L	-4(A1), A3	; load type desc ptr - is marked!	BRA.S		PtrLoop	ENDP*------------------------------------------------------------------------------------* PROCEDURE Scan		; Scan Heap, Collecting Free Blocks*Scan	PROC	EXPORT	LEA.L	G.PtrTbl(A5), A0	MOVEQ.L	#8, D0	; must clear tblsize+1 locations@1	CLR.L	(A0)+	DBF.W	D0, @1	LEA.L	G.HeapRoot(A5), A3	; A4: previous block; A3: current blockForward	MOVEA.L	A3, A4	MOVEA.L	(A3), A3ChkLast	TST.L	A3	BEQ.S	EndScan	TST.L	4(A3)	BEQ.S	Enter	; nil tag: subdivided chunk	BCLR.B	#0, 7(A3)	BNE.S	ForwardDispose	MOVE.L	A3, A0	MOVEA.L	(A3), A3	MOVE.L	A3, (A4)	_DisposPtr	BRA.S	ChkLastEndScan	RTSEnter	LEA.L	12(A3), A2	; A2: current block	MOVE.L	A2, D6	ADD.L	#$FFF0, D6	; D6= Block Limit	BCLR.B	#0, -1(A2)	BEQ.S	UnmarkedMarked	MOVEA.L	-4(A2), A0	MOVE.L	(A0), D7	LEA	0(A2, D7.L*4), A2	; next record	CMP.L	A2, D6	BEQ.S	Forward	BCLR.B	#0,-1(A2)	BNE.S	MarkedUnmarked	MOVEA.L	A2, A1	; A1: first continuous unmarked blockMoreUnmkd	MOVE.L	-4(A2), A0	MOVE.L	(A0), D7	LEA	0(A2, D7.L*4), A2	; next record	CMP.L	A2, D6	BEQ.S	RestUnmkd	BCLR.B	#0, -1(A2)	BEQ.S	MoreUnmkd	MOVE.L	A2, D0	; unmarked blocks from (A1)..(A2)	SUB.L	A1, D0	BSR.S	Link	BRA.S	MarkedRestUnmkd	MOVE.L	A2, D0	; completely empty?	SUB.L	A1, D0	CMP.L	#$FFF0, D0	BEQ.S	Dispose	BSR.S	Link	BRA.S	ForwardLink	LSR.L	#2, D0	LEA	4(A1), A0	MOVE.L	A0, -4(A1)	; pseudo tag	MOVE.L	D0, 4(A1)	; (size DIV 4)	CMP.L	#36, D0	BLS.S	Register	MOVEQ.L	#36, D0Register	LEA.L	-72(A5, D0.L), A0	; should be "G.PtrTbl-4(A5, D0.L)"	MOVE.L	(A0), (A1)	; insert	MOVE.L	A1, (A0)	RTS	ENDP*------------------------------------------------------------------------------------* BEGIN*Main	MAIN	IMPORT	NewLarge, NewSmall, NewSys, Mark, Scan	MOVE.L	#gestaltProcessorType, D0	_Gestalt	CMPA.L	#3, A0	BLT.W	errCPU	MOVE.L	#gestaltFPUType, D0	_Gestalt	TST.L	A0	BEQ.W	errFPU	MOVE.L	#gestaltQuickDrawVersion, D0	_Gestalt	CMPA.L	#256, A0	BLT.W	errQD	MOVE.L	A5, D0	SUB.L	ApplZone, D0	CMPI.L	#1048576, D0	BLT.W	errMem	LEA.L	NewSmall, A0	MOVE.L	A0, G.NewSmall(A5)	LEA.L	NewLarge, A0	MOVE.L	A0, G.NewLarge(A5)	LEA.L	NewSys, A0	MOVE.L	A0, G.NewSys(A5)	LEA.L	Mark1, A0	MOVE.L	A0, G.Mark1(A5)	LEA.L	Scan, A0	MOVE.L	A0, G.Scan(A5)	CLR.L	G.HeapRoot(A5)	MOVE.L	#-1, G.Sentinel(A5)	LEA.L	G.PtrTbl(A5), A0	MOVEQ.L	#8, D0	; clear table@1	CLR.L	(A0)+	DBF.W	D0, @1BootLoad	MOVE.L	#'bCOD', -(A7)	MOVE.W	#1, -(A7)	_GetResource	MOVE.L	(A7), A2	_DetachResource	MOVEA.L	A2, A0	_HLock	MOVEA.L	(A2), A1	; A1: resource base	MOVE.L	A2, G.ResHandle(A5)	BSR.S	RNum	MOVE.L	D1, D0	_NewPtr	,CLEAR	MOVE.L	A0, D2	; D2: heap base	MOVEA.L	A0, A2	; A2: current heap pos	MOVEA.L	A0, A3	; A3: current fixup pos	RBlock	BSR.S	RNum	; {bcount {bytes} zcount}	BEQ.S	RFix	; until (bcount=0) OR (zcount=0)	SUBQ.L	#1, D1RBytes	MOVE.B	(A1)+, (A2)+	DBF	D1, RBytes	BSR.S	RNum	BEQ.S	RFix	ADDA.L	D1, A2	BRA.S	RBlockRFix	BSR.S	RNum	; {fixpos} until fixpos=0	BEQ.S	DoneFix	ADDA.L	D1, A3	ADD.L	D2, (A3)	BRA.S	RFix	DoneFix	_CacheFlush	BSR.S	RNum	ADD.L	D2, D1	MOVE.L	D1, G.ModRoot(A5)	BSR.S	RNum	ADD.L	D2, D1	MOVEA.L	D1, A4	; A4: first body to be initialized	RBody	BSR.S	RNum	; D1: offset of next body	BEQ.S	Start	; is body in A4 the final one?	MOVEM.L	D1-D2/A0-A1, -(A7)	JSR	(A4)	MOVEM.L	(A7)+, D1-D2/A0-A1	ADD.L	D2, D1	MOVEA.L	D1, A4	BRA.S	RBodyStart	MOVE.L	G.ResHandle(A5), A0	_DisposHandle	SUBA.L	A6, A6	JSR	(A4)	_ExitToShell		RNum	CLR.L	D1	; D1: result	CLR.L	D7	; D7: counter	RByte	CLR.L	D6	; D6: shift scratch	MOVE.B	(A1), D6		ADDA.L	#1, A1		BCLR	#7, D6	BEQ.S	HiByte	LSL.L	D7, D6	OR.L	D6, D1	ADDQ.L	#7, D7	BRA.S	RByteHiByte	LSL.L	D7, D6	OR.L	D6, D1	RTSerrCPU	MOVE.W	#32766, -(A7)	BRA.S	ErrorerrFPU	MOVE.W	#32765, -(A7)	BRA.S	ErrorerrQD	MOVE.W	#32764, -(A7)	BRA.S	ErrorerrMem	MOVE.W	#32763, -(A7)Error	PEA	QD.thePort	_InitGraf	_InitFonts	_InitWindows	_InitMenus	_TEInit	CLR.L	-(A7)	_InitDialogs	_InitCursor	CLR.L	-(A7)	_Alert	_ExitToShell	ENDP	END