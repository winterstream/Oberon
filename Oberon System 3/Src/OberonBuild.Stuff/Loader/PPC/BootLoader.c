/*********************************************************************//* Bootloader for PowerPC/MacOberon, tk 28.12.96					 *//*********************************************************************/#include <string.h>#include <stdio.h>#include <FragLoad.h>extern pascal void MakeDataExecutable(void *baseAddress, unsigned long length);#define	B	16typedef struct cmd {	signed long pc, sb;} Command, PROCEDURE;long		bootAdr, oberonModList;long		restFProc, saveFProc;PROCEDURE 	tempSym;/*************** External System Procedures ***************/static void InitProcVar(PROCEDURE* pv, long* proc) {	pv->pc = proc[0]; pv->sb = proc[1];}static ConnectionID ThisLib (char* name, long len, unsigned char ppc) {	Str63 s; Str255 errName;	OSErr err; OSType arch;	ConnectionID connID;	Ptr adr;	short i;		for (i = 0; name[i] != 0; i++) s[i+1] = name[i]; s[0] = i;	if (ppc) arch = kPowerPCArch; 	else arch = kMotorola68KArch;	err = GetSharedLibrary(s, arch, kLoadLib, &connID, &adr, errName);	if (err == 0) return connID;	else return 0;}// for debugging purposesstatic void Print (char *s, long len, long n) {	// short i=n;	// for (i=0; s[i] != 0; i++); s[i++]=13; s[i]=0;}static char* ecvt (double x, int n) {	static char s[64];	char format[8];	strcpy(format, "%10.00e");	n -= 8;	format[4] = n/10+'0';	format[5] = n%10+'0'; 	sprintf(s, format, x);	return s;}static long ThisSym (long connID, char* name, long len) {	OSErr err;	Ptr symAdr;	SymClass symClass;	Str255 s;	short i;		if (strcmp(name, "SYSPrint")==0) { 	InitProcVar(&tempSym, (long*)Print); return (long)&tempSym;}	if (strcmp(name, "SYSThisLib")==0) { InitProcVar(&tempSym, (long*)ThisLib); return (long)&tempSym; }	if (strcmp(name, "SYSecvt")==0) { InitProcVar(&tempSym, (long*)ecvt); return (long)&tempSym; }	if (strcmp(name, "SYSFPURegProcs")==0) { tempSym.pc = saveFProc; tempSym.sb = restFProc; return (long)&tempSym; }	if (strcmp(name, "SYSModList")==0) { tempSym.pc = oberonModList; return (long)&tempSym; }	for (i = 0; name[i] != 0; i++) s[i+1] = name[i]; s[0] = i;	err = FindSymbol(connID, s, &symAdr, &symClass);	if (err == 0) return (long)symAdr; 	else return NULL;}/*************** Reading Bootfile And Launching Command ***************/static long RLInt(void)	{ 	long n = *((long*)bootAdr); 	bootAdr+=sizeof(long); 	return n; }static void Boot(){	long	fileCodeAdr, oberonCodeSize, oberonCodeAdr, shift, adr, end, i, no, no0, no1, long1, long2, 			mod, u, l, fixval, instr, proc;	Handle	bootFile;	Ptr		oberonCodeSeg;	Command	cmd; 	void (*body)(void);	long  (*thisMod)(char [], long);	void (*thisCmd)(long, char [], long, Command*);	char cmdModName[32], cmdName[32];		bootFile = GetResource('bCOD', 0);	if (bootFile==NULL) return; // printf("oberon: boot file not found\n"); 		HLock(bootFile);	bootAdr = (long)*bootFile;	fileCodeAdr = RLInt(); oberonCodeSize = RLInt();	/* allocate module space */	oberonCodeSeg = NewPtrClear(oberonCodeSize + B);	if (oberonCodeSeg == NULL) return; // printf("oberon: could not allocate code segment\n");	oberonCodeAdr = (long)oberonCodeSeg;	/* aline to B-boundaries */	oberonCodeAdr = (oberonCodeAdr + B - 1) & 0xfffffff0;	shift = oberonCodeAdr - fileCodeAdr;	// adr = oberonCodeAdr; end = oberonCodeAdr + oberonCodeSize;	// while (adr!=end) { (*(int *)adr)=RLInt(); adr+=4; }		/* read heap */	adr = oberonCodeAdr;	while ((end = RLInt())!=0) {	  i=0; while (i<end) { *((char*)adr)=*((char *)bootAdr); adr++; bootAdr++; i++; }	  if ((end=RLInt())==0) break;	  adr += end;	}	/* fix longs */	no = RLInt();	while ((no--)>0) { 		adr=RLInt() + oberonCodeAdr;  		*((long *)adr) += shift;	}	/* fix splits in case-statements and branches */	no = RLInt();	while ((no--)>0) {		adr = RLInt() + oberonCodeAdr;		long1 = *((long *)adr); long2 = *((long *)(adr + 4)); 		u = long1 & 0xffff; l = long2 & 0xffff;		fixval = ((u - (l>>15))<<16) + l + shift;		u = ((fixval>>16) + (((fixval)>>15)&1)) & 0x0000ffff;		l = fixval & 0x0000ffff;		instr = long1 & 0xffff0000; *((long *)adr) = instr | u; 		instr = long2 & 0xffff0000; *((long *)(adr + 4)) = instr | l;	}	/* modList */	oberonModList = RLInt() + oberonCodeAdr;	/* ThisSym */	adr = RLInt();	if (adr!=0) {		adr = adr + oberonCodeAdr + 0;		proc = (long)ThisSym;		*((long *)adr) = *((long *)proc);				/* pc */		*((long *)(adr+4)) = *((long *)(proc+4));		/* sb */	}	/* SaveFProc, RestFProc */	saveFProc = oberonCodeAdr;	restFProc = oberonCodeAdr + 33*4;		MakeDataExecutable(oberonCodeSeg, oberonCodeSize);	/* call module bodies */	while ((adr = RLInt()) != 0) 	{		body = (void(*)(void))&cmd;		cmd.pc = adr+shift;		cmd.sb = RLInt()+shift; 		(*body)();	}	/* read command name */	no0 = 0; do { cmdModName[no0++]=*((char*)(bootAdr++)); } while (cmdModName[no0-1]!='.');	cmdModName[no0-1]='\0';	no1 = 0; do { cmdName[no1++]=*((char*)(bootAdr++)); } while (cmdName[no1-1]!='\0');    cmdName[no1-1]='\0';		thisMod = (long(*)(char [], long))&cmd;	thisCmd = (void(*)(long, char [], long, Command*))&cmd;	/* Call Modules.ThisMod */	cmd.sb = RLInt()+shift; cmd.pc = RLInt()+shift;	mod = (*thisMod)(&cmdModName[0], no0);	/* Call Modules.ThisCommand */	cmd.pc = RLInt()+shift;	(*thisCmd)(mod, &cmdName[0], no1, &cmd); 	body = (void(*)(void))&cmd;	/* Call Command */	HUnlock(bootFile);	(*body)();}void main(){	Boot();}/*************** Boot File Description ***************//*BootFile:	heapAdr	heapSize		heap		SaveFProc		RestFProc		{ Data }	nofLFix { adr }	nofSFix { adr }	modList	SysSB	{ modBodyAdr modSBAdr } 0	cmdName	modSB thisModAdr thisCmdAdr*/